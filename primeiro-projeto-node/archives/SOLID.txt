S // Single Responsability Principle (uma classe deve ter apenas um motivo para mudar, ou seja, deve ter uma única responsabilidade)
O // Open Closed Principle (entidades de software devem ser abertas para uma extensão --herança e implementação-- , mas fechadas para modificação)
L // Liskov Substitution Principle (os subtipos devem ser substituídos por seus tipos básicos)
I // Interface Segregation Principle (muitas interfaces específicas são melhores do que uma interface geral --interfaces que possuem muitos comportamentos são difíceis de manter-- )
D // Dependency Inversion Principle (  "depender de abstrações e não de classes concretas"
                                        Módulos de alto nível não devem depender de módulos de baixo nível
                                        Ambos devem depender de abstrações)
